---
description: Kod tabanÄ± analizi ve dosya boyutu audit - Implementasyondan Ã¶nce zorunlu codebase anlayÄ±ÅŸÄ±
globs:
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.py"
  - "**/*.vue"
alwaysApply: false
priority: 3
triggers: ['new_feature_request', 'existing_codebase_modification', 'refactoring_need']
conditions: ['existing_project = true', 'file_count > 5']
mandatory_steps: ['file_size_audit', 'architecture_mapping', 'dependency_analysis']
depends_on: ['file-size-enforcement.mdc']
---

# KOD TABANI ANALÄ°ZÄ° - ZORUNLU ANLAYIÅ

## TEMEL PRENSÄ°P - UNDERSTAND BEFORE IMPLEMENT

Bu component'in temel felsefesi Ã§ok nettir: Herhangi bir kod deÄŸiÅŸikliÄŸi yapmadan Ã¶nce mevcut kod tabanÄ±nÄ± tamamen anlamak zorunludur. Bu yaklaÅŸÄ±m hem kod kalitesini korur hem de yanlÄ±ÅŸ implementasyonlarÄ± Ã¶nler.

## ZORUNLU ANALÄ°Z PROTOKOLÃœ - MANDATORY STEPS

Sistem her implementasyon isteÄŸinde ÅŸu adÄ±mlarÄ± zorunlu olarak gerÃ§ekleÅŸtirir:

### ADIM 1: DOSYA BOYUTU AUDÄ°TÄ° (Mutlak Ã–ncelik)
Ä°lk adÄ±m her zaman dosya boyutlarÄ±nÄ±n kontrol edilmesidir Ã§Ã¼nkÃ¼ bu sonraki tÃ¼m iÅŸlemleri etkiler:

```javascript
function performFileSizeAudit(projectPath) {
    const allFiles = scanProjectFiles(projectPath);
    const sizeReport = allFiles.map(file => ({
        path: file.path,
        lineCount: countLines(file),
        status: determineStatus(countLines(file)),
        violationType: getViolationType(countLines(file))
    }));
    
    const violations = sizeReport.filter(file => file.lineCount > 700);
    const critical = sizeReport.filter(file => file.lineCount > 1000);
    
    return {
        totalFiles: allFiles.length,
        violations: violations,
        criticalViolations: critical,
        implementationBlocked: violations.length > 0
    };
}
```

**Dosya boyutu durumlarÄ±:**
- **0-500 satÄ±r**: GÃ¼venli - yeni kod eklenebilir
- **500-699 satÄ±r**: YaklaÅŸÄ±yor - dikkatli ekleme
- **700-999 satÄ±r**: Ä°hlal - yeni kod bloke edilir
- **1000+ satÄ±r**: Kritik - acil refactoring gerekli

### ADIM 2: MÄ°MARÄ° HARÄ°TALAMA
Kod tabanÄ±nÄ±n genel yapÄ±sÄ±nÄ± anlamak iÃ§in systematic bir analiz yapÄ±lÄ±r:

```javascript
function mapProjectArchitecture(projectPath) {
    return {
        frameworkType: detectFramework(projectPath),
        componentStructure: analyzeComponentHierarchy(projectPath),
        dependencyFlow: traceDependencies(projectPath),
        designPatterns: identifyPatterns(projectPath),
        codeOrganization: assessOrganization(projectPath)
    };
}
```

**Mimari analiz Ã§Ä±ktÄ±larÄ±:**
- Proje tipi tespiti (React, Vue, Node.js, Python vs.)
- Component hiyerarÅŸisi haritasÄ±
- BaÄŸÄ±mlÄ±lÄ±k akÄ±ÅŸ diyagramÄ±
- KullanÄ±lan design pattern'lar
- Kod organizasyon yapÄ±sÄ± deÄŸerlendirmesi

### ADIM 3: BAÄIMLILIK ANALÄ°ZÄ°
Mevcut kodun nasÄ±l birbirine baÄŸlÄ± olduÄŸunu anlamak kritiktir:

```javascript
function analyzeDependencies(projectPath) {
    const importGraph = buildImportGraph(projectPath);
    const circularDeps = detectCircularDependencies(importGraph);
    const unusedImports = findUnusedImports(projectPath);
    const externalDeps = analyzeExternalDependencies(projectPath);
    
    return {
        importStructure: importGraph,
        circularDependencies: circularDeps,
        unusedImports: unusedImports,
        externalDependencies: externalDeps,
        dependencyHealth: assessDependencyHealth(importGraph)
    };
}
```

## CONTEXT DETECTION SÄ°STEMÄ° - AKILLI ANALIZ

Sistem farklÄ± proje tiplerini otomatik olarak tanÄ±r ve buna gÃ¶re analiz stratejisini uyarlar:

### REACT PROJE ANALÄ°ZÄ°
React projelerinde Ã¶zel olarak aranacak pattern'lar:
- Component composition yapÄ±larÄ±
- Hook kullanÄ±m pattern'larÄ±  
- State management yaklaÅŸÄ±mlarÄ±
- Context API kullanÄ±mlarÄ±
- Custom hook'larÄ±n yeri ve kullanÄ±mÄ±

```javascript
function analyzeReactProject(projectPath) {
    return {
        componentTypes: categorizeComponents(projectPath),
        hookUsage: analyzeHookPatterns(projectPath),
        stateManagement: detectStateManagement(projectPath),
        routingStructure: analyzeRouting(projectPath)
    };
}
```

### NODE.JS BACKEND ANALÄ°ZÄ°
Backend projelerinde odaklanÄ±lacak alanlar:
- API endpoint yapÄ±larÄ±
- Database connection pattern'larÄ±
- Middleware kullanÄ±mlarÄ±
- Error handling yaklaÅŸÄ±mlarÄ±

### PYTHON PROJE ANALÄ°ZÄ°
Python projelerinde incelenecek konular:
- Module organization pattern'larÄ±
- Class hierarchy'leri
- Function organization yaklaÅŸÄ±mlarÄ±
- Package structure mantÄ±ÄŸÄ±

## BLOKLAMA KRÄ°TERLERÄ° - IMPLEMENTATION PREVENTION

Belirli durumlar tespit edildiÄŸinde implementasyon derhal durdurulur:

### OTOMATIK BLOKLAMA DURUMLAR
```javascript
function shouldBlockImplementation(analysisResults) {
    const blockingConditions = [
        analysisResults.fileSizeViolations.length > 0,
        analysisResults.criticalArchitecturalIssues.length > 0,
        analysisResults.circularDependencies.length > 0,
        analysisResults.majorRefactoringNeeded === true
    ];
    
    return blockingConditions.some(condition => condition === true);
}
```

**Bloklama sebepleri:**
- **Dosya boyutu ihlalleri**: 700+ satÄ±rlÄ± dosyalar
- **Kritik mimari sorunlar**: Circular dependencies, god objects
- **Tehlikeli baÄŸÄ±mlÄ±lÄ±klar**: Unused imports, broken dependencies
- **BÃ¼yÃ¼k refactoring ihtiyacÄ±**: Systematic deÄŸiÅŸiklikler gerekli

### BLOKLAMA Ä°LETÄ°ÅÄ°MÄ°
```
ğŸ›‘ IMPLEMENTASYON DURDURULDU
ğŸ“Š Analiz sonuÃ§larÄ±:
   ğŸ“ Dosya boyutu ihlalleri: [X dosya > 700 satÄ±r]
   ğŸ—ï¸ Mimari sorunlar: [tespit edilen sorunlar]
   ğŸ”— BaÄŸÄ±mlÄ±lÄ±k problemleri: [circular deps, unused imports]

ğŸ”„ GEREKLÄ° AKSÄ°YONLAR:
   1. [Spesifik refactoring adÄ±mlarÄ±]
   2. [Dosya bÃ¶lme Ã¶nerileri]  
   3. [Mimari dÃ¼zenlemeler]

âš ï¸ Ä°mplementasyon bu sorunlar Ã§Ã¶zÃ¼lene kadar bloke edilmiÅŸtir.
```

## Ã–ÄRENME MODELLERÄ° - CODEBASE UNDERSTANDING

FarklÄ± karmaÅŸÄ±klÄ±k seviyelerinde farklÄ± analiz derinlikleri uygulanÄ±r:

### BASIT PROJELER (< 10 dosya)
- Temel dosya yapÄ±sÄ± analizi
- Import/export iliÅŸkileri
- Temel pattern tanÄ±ma

### ORTA PROJELER (10-50 dosya)
- DetaylÄ± mimari analiz
- Component interaction mapping
- Performance impact assessment
- Code quality metrics

### KARMAÅIK PROJELER (50+ dosya)
- Comprehensive architectural review
- Cross-module dependency analysis
- Scalability assessment
- Technical debt identification

## ANALÄ°Z RAPORLAMA - COMPREHENSIVE REPORTING

Her analiz sonunda kullanÄ±cÄ±ya detaylÄ± rapor sunulur:

### ANALÄ°Z RAPORU FORMATI
```
ğŸ“Š KOD TABANI ANALÄ°Z RAPORU:

ğŸ—ï¸ PROJE MÄ°MARÄ°SÄ°:
   ğŸ“‹ Tip: [React/Vue/Node.js/Python]
   ğŸ“ Dosya sayÄ±sÄ±: [X dosya]
   ğŸ¯ Ana pattern'lar: [tespit edilen design patterns]

ğŸ“ DOSYA BOYUT DURUMU:
   âœ… GÃ¼venli dosyalar: [X dosya] (< 700 satÄ±r)
   âš ï¸ YaklaÅŸan limitler: [X dosya] (500-699 satÄ±r)  
   ğŸš« Ä°hlaller: [X dosya] (700+ satÄ±r)
   ğŸ’¥ Kritik durumlar: [X dosya] (1000+ satÄ±r)

ğŸ”— BAÄIMLILIK DURUMU:
   ğŸ“¦ Import yapÄ±sÄ±: [saÄŸlÄ±klÄ±/sorunlu]
   â™»ï¸ Circular dependencies: [X adet]
   âŒ Unused imports: [X adet]
   ğŸ”§ Temizlik gerekli: [evet/hayÄ±r]

ğŸ¯ Ä°MPLEMENTASYON DURUMMANÄ±:
   [âœ… HazÄ±r / ğŸ”„ Refactoring sonrasÄ± / ğŸ›‘ Bloke]
```

### REFACTORING Ã–NERÄ°LERÄ°
Analiz sonunda sistemik Ã¶neriler sunulur:

```
ğŸ”§ REFACTORING Ã–NERÄ°LERÄ°:

ğŸ“ DOSYA BOYUTU Ä°Ã‡Ä°N:
   â€¢ [FileName.tsx] dosyasÄ±nÄ± bÃ¶l â†’ [3 Ã¶nerilen dosya]
   â€¢ [AnotherFile.js] utility extraction â†’ [2 yeni dosya]

ğŸ—ï¸ MÄ°MARÄ° Ä°YÄ°LEÅTÄ°RME:
   â€¢ Component hierarchy dÃ¼zenle
   â€¢ Service layer seperation
   â€¢ Custom hook extraction

ğŸ”— BAÄIMLILIK TEMÄ°ZLÄ°ÄÄ°:
   â€¢ [X adet] unused import kaldÄ±r
   â€¢ Circular dependency Ã§Ã¶z: [spesifik Ã¶neriler]
   â€¢ Import organization: [grup bazlÄ± dÃ¼zenleme]
```

## KALÄ°TE GÃœVENCESÄ° - ANALYSIS VALIDATION

Analizin doÄŸruluÄŸunu saÄŸlamak iÃ§in Ã§oklu validasyon katmanlarÄ±:

### PRE-ANALYSIS VALIDATION
- Proje yapÄ±sÄ±nÄ±n okunabilir olduÄŸunu kontrol et
- File path'lerin eriÅŸilebilir olduÄŸunu doÄŸrula
- Permission sorunlarÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol et

### POST-ANALYSIS VERIFICATION  
- Analysis sonuÃ§larÄ±nÄ±n consistent olduÄŸunu kontrol et
- Cross-reference farklÄ± analiz sonuÃ§larÄ±nÄ±
- Missing information varsa ikinci pass yap

### CONTINUOUS MONITORING
- Analiz sÄ±rasÄ±nda deÄŸiÅŸen dosyalarÄ± tekrar kontrol et
- Real-time size monitoring yap
- Dynamic dependency changes'i takip et

Bu comprehensive yaklaÅŸÄ±m sayesinde hiÃ§bir implementasyon eksik bilgiyle yapÄ±lmaz ve kod kalitesi sÃ¼rekli olarak korunur. Analiz sÃ¼reci gÃ¶rÃ¼nÃ¼rde zaman alÄ±yor gibi gÃ¶zÃ¼kse de, sonrasÄ±nda yapÄ±lacak implementasyonun doÄŸruluÄŸunu ve kalitesini garanti ediyor.

---

*Kod tabanÄ±nÄ± anlamadan implementasyon yapmak, karanlÄ±kta yÃ¼rÃ¼mek gibidir. Bu analiz sÃ¼reci implementasyonun Ä±ÅŸÄ±ÄŸÄ±dÄ±r.*