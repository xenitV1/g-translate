---
description: Tek dosya ve basit deÄŸiÅŸiklikler iÃ§in optimize edilmiÅŸ hÄ±zlÄ± gÃ¶rev yÃ¶netimi - MCP tool kullanmadan direkt implementasyon
globs:
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.ts"
  - "**/*.tsx" 
  - "**/*.css"
  - "**/*.scss"
alwaysApply: false
priority: 4
triggers: ['single_file_modification', 'simple_implementation', 'quick_fix', 'minor_feature_addition']
conditions: ['file_count <= 2', 'line_changes < 50', 'no_new_dependencies']
mcp_tools: disabled
depends_on: ['file-size-enforcement.mdc', 'clean-code-standards.mdc', 'language-rules.mdc']
---

# BASÄ°T GÃ–REV YÃ–NETÄ°MÄ° - HIZLI VE ETKÄ°LÄ°

## TANIM - BASÄ°T GÃ–REV NEDÄ°R?

Basit gÃ¶rev tanÄ±mÄ± net ve Ã¶lÃ§Ã¼lebilir kriterlerle belirlenir:

### BASÄ°T GÃ–REV KRÄ°TERLERÄ°
âœ… **Dosya sayÄ±sÄ±**: 1-2 dosya maksimum  
âœ… **SatÄ±r deÄŸiÅŸimi**: 50 satÄ±rdan az ekleme/deÄŸiÅŸiklik  
âœ… **Complexity**: Tek bir feature veya bug fix  
âœ… **Dependency**: Yeni kÃ¼tÃ¼phane gerektirmez  
âœ… **Scope**: Tek component veya single function  

### BASÄ°T GÃ–REV Ã–RNEKLERÄ°
- Button component oluÅŸturma
- CSS styling deÄŸiÅŸiklikleri  
- Tek bir bug dÃ¼zeltme
- Form validation ekleme
- Loading state implementasyonu
- Single hook oluÅŸturma
- Utility function yazma

## STREAMLINED WORKFLOW - OPTÄ°MÄ°ZE EDÄ°LMÄ°Å SÃœREÃ‡

### 3-STEP PROCESS
Basit gÃ¶revler iÃ§in Ã§ok hÄ±zlÄ± ve verimli bir sÃ¼reÃ§:

```
1. FAST CHECK â†’ 2. DIRECT IMPLEMENT â†’ 3. QUALITY VALIDATE
     (5 sn)            (Ana iÅŸlem)              (10 sn)
```

#### STEP 1: FAST CHECK (HÄ±zlÄ± Kontrol)
```javascript
function fastPreCheck() {
    return {
        fileSizeOk: checkTargetFileSize() < 700,
        scopeSimple: isTaskScopeSimple(),
        dependencyClean: noNewDependenciesRequired()
    };
}
```

**Fast check items:**
- [ ] **Hedef dosya boyutu** < 700 satÄ±r (2 saniye)
- [ ] **Task scope** basit mi? (2 saniye)  
- [ ] **Yeni dependency** gerekiyor mu? (1 saniye)

#### STEP 2: DIRECT IMPLEMENT (Direkt Uygulama)  
Fast check'i geÃ§erse direkt implementasyon:
- âœ… **No MCP tools** (zaman kaybÄ± olmaz)
- âœ… **Direct code writing** (anÄ±nda baÅŸla)
- âœ… **Focused implementation** (sadece gerekli kod)
- âœ… **Minimal approach** (over-engineering yok)

#### STEP 3: QUALITY VALIDATE (Kalite DoÄŸrulama)
```javascript
function quickQualityCheck() {
    return {
        unusedImportsRemoved: cleanupImports(),
        deadCodeEliminated: removeDeadCode(),
        fileSizeCompliant: checkFinalFileSize(),
        singleResponsibility: validateComponentFocus()
    };
}
```

## NO MCP TOOLS POLICY - HIZLI EXECUTION

### NEDEN MCP TOOL YOK?
Basit gÃ¶revlerde MCP tool kullanÄ±mÄ± efficiency kaybÄ± yaratÄ±r:

**MCP tool overhead:**
- Sequential thinking: +15-30 saniye
- Context switching: +10 saniye  
- Tool initialization: +5 saniye
- **Total overhead**: +30-45 saniye

**Direct approach benefit:**
- Immediate implementation: 0 saniye overhead
- Focused execution: Daha az distraction
- Faster user feedback: AnÄ±nda sonuÃ§

### MCP TOOL EXCEPTIONS - SINIRLI KULLANIM
Sadece bu durumlar da MCP tool kullan:
- **Unknown codebase**: HiÃ§ gÃ¶rÃ¼lmemiÅŸ proje yapÄ±sÄ±
- **Complex dependencies**: 3+ dosya interaction
- **User explicitly requests**: "AdÄ±m adÄ±m aÃ§Ä±kla"

## IMPLEMENTATION PATTERNS - PROVEN FORMULAS

### COMPONENT CREATION PATTERN
```javascript
// Template for simple component creation
const NewComponent = ({ prop1, prop2 }) => {
  // Single responsibility focus
  const handleAction = () => {
    // Minimal logic
  };

  return (
    <div className="component-container">
      {/* Clean, focused JSX */}
    </div>
  );
};

export default NewComponent;
```

### UTILITY FUNCTION PATTERN
```javascript
// Template for simple utility functions  
export const utilityFunction = (input) => {
  // Input validation (if needed)
  if (!input) return null;
  
  // Core logic (minimal)
  const result = processInput(input);
  
  // Return processed result
  return result;
};
```

### BUG FIX PATTERN  
```javascript
// Template for simple bug fixes
// 1. Identify the minimal change needed
// 2. Apply the fix without over-engineering  
// 3. Test the specific fix (no scope creep)

// Example:
// âŒ Before (buggy)
const calculateTotal = (items) => {
  return items.reduce((sum, item) => sum + item.price); // Missing initial value
};

// âœ… After (fixed)
const calculateTotal = (items) => {
  return items.reduce((sum, item) => sum + item.price, 0);
};
```

## EFFICIENCY OPTIMIZATION - ZAMAN TASARRUFU

### TIME SAVING STRATEGIES

**Import management optimization:**
```javascript
// Automatic import optimization during implementation
// Instead of asking user, just clean and organize
import React, { useState } from 'react'; // Consolidated  
import { Button, Input } from './components'; // Organized
// Removed: import { unused } from 'somewhere'; // Auto-removed
```

**Code structure optimization:**
```javascript
// Apply single responsibility automatically
// If component doing multiple things, suggest split immediately:

// âŒ Detected: Multiple responsibilities
const UserProfileAndSettings = () => {/*...*/};

// âœ… Auto-suggest split:
"Bu component iki farklÄ± gÃ¶rev yapÄ±yor. Ä°kiye bÃ¶lelim:"
// UserProfile.jsx
// UserSettings.jsx
```

### RAPID FEEDBACK LOOPS

**Immediate status reporting:**
```
ğŸš€ BASÄ°T GÃ–REV - HIZLI MMOD
ğŸ“ Hedef: Button.jsx (156 satÄ±r / 1000 limit - âœ… UYGUN)  
âš¡ Implementing... (direkt kod yazÄ±yor)
ğŸ§¹ Auto-cleanup: 1 unused import removed
âœ… TamamlandÄ±: 23 satÄ±r eklendi, kalite kontrol geÃ§ti
```

## QUALITY GATES - SIMPLIFIED VALIDATION

### PRE-IMPLEMENTATION (HÄ±zlÄ±)
- [ ] File size < 700 lines (2 sn check)
- [ ] Scope is simple (mental check)  
- [ ] No new dependencies needed

### POST-IMPLEMENTATION (Otomatik)
- [ ] Unused imports cleaned âœ…
- [ ] Dead code removed âœ…  
- [ ] File size still compliant âœ…
- [ ] Single responsibility maintained âœ…

### QUALITY REPORT - CONCISE FORMAT
```
âœ… BASÄ°T GÃ–REV TAMAMLANDI
ğŸ¯ YapÄ±lan: [specific implementation] 
ğŸ“ Dosya durumu: [X satÄ±r] (+[Y added]) - [STATUS]
ğŸ§¹ Otomatik temizlik: [cleanup summary]
âš¡ SÃ¼re: [estimated time] - [efficiency note]
```

## ERROR HANDLING - RAPID RESOLUTION

### COMMON SIMPLE TASK ERRORS

**File size violation:**
```
ğŸ›‘ HIZLI MMOD ENGELLEME  
ğŸ“ Hedef dosya: [X satÄ±r] > 700 limit
ğŸ”„ Gerekli: Ã–nce refactoring, sonra feature
ğŸ“‹ HÄ±zlÄ± Ã§Ã¶zÃ¼m: [specific refactoring steps]
```

**Scope creep detection:**
```  
âš ï¸ SCOPE ARTIÅI TESPÄ°T EDÄ°LDÄ°
ğŸ¯ BaÅŸlangÄ±Ã§: [original simple task]
ğŸ“ˆ Mevcut: [expanded scope]  
ğŸ”„ Ã–neri: Scope'u basit tut veya complex mode'a geÃ§
```

## PERFORMANCE TRACKING

### EFFICIENCY METRICS
- **Task completion time**: < 2 dakika target
- **Code quality score**: Automatic validation pass
- **User satisfaction**: Immediate working solution
- **File size impact**: Minimal size increase

### OPTIMIZATION OPPORTUNITIES
```
ğŸ“Š BASÄ°T GÃ–REV PERFORMANCE:
â±ï¸  Ortalama sÃ¼re: [X saniye]  
ğŸ¯ BaÅŸarÄ± oranÄ±: [%X tasks completed without issues]
ğŸ”„ Refactoring trigger: [%X tasks needed file splitting]  
âš¡ Efficiency gain: [X%] faster than complex mode
```

## ESCALATION RULES - COMPLEXITY DETECTION

### WHEN TO SWITCH TO COMPLEX MODE
Basit gÃ¶rev sÄ±rasÄ±nda ÅŸu durumlar tespit edilirse complex mode'a geÃ§:

- **File size violation** detected (>700 lines)
- **Multiple file modification** needed  
- **New dependency** requirements emerge
- **Architecture change** needed
- **User requests step-by-step** explanation

**Escalation message:**
```
ğŸ”„ COMPLEX MODE'A GEÃ‡Ä°Å GEREKÄ°YOR
ğŸ“‹ Sebep: [escalation reason]
ğŸ¯ Yeni yaklaÅŸÄ±m: [complex project management]
ğŸ“š YÃ¼klenen componentler: [list of additional components]
```

## SÄ°STEM ENTEGRASYONU

### COMPONENT INTERACTION OPTIMIZATION
- `file-size-enforcement.mdc`: Pre-check olarak fast integration  
- `clean-code-standards.mdc`: Post-implementation auto-apply
- `language-rules.mdc`: Continuous Turkish communication

### EFFICIENCY PRIORITIZATION
1. **Speed**: En hÄ±zlÄ± Ã§alÄ±ÅŸan Ã§Ã¶zÃ¼m
2. **Quality**: Otomatik kalite standartlarÄ±  
3. **Simplicity**: Over-engineering prevention
4. **User satisfaction**: Immediate working result

---

*Basit gÃ¶revler iÃ§in over-engineering yapmak efficiency katilidir. Bu component maksimum hÄ±z ve kalite dengesini optimize eder.*