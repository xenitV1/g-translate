---
description: MCP araÃ§larÄ±nÄ±n akÄ±llÄ± ve seÃ§ici kullanÄ±mÄ± - Sadece karmaÅŸÄ±k Ã§oklu adÄ±m gÃ¶revler ve bilinmeyen teknolojiler iÃ§in
globs:
  - "**/*"
alwaysApply: false
priority: 4
triggers: ['complex_multi_step_tasks', 'unfamiliar_codebase_exploration', 'systematic_debugging', 'user_learning_requests']
conditions: ['complexity >= complex', 'steps >= 3', 'unknown_technology = true', 'user_requests_explanation = true']
mcp_tools: ['sequential-thinking', 'context7']
activation_threshold: 0.6
---

# MCP TOOL KULLANIMI - AKILLI VE SEÃ‡Ä°CÄ°

## TEMEL FELSEFESÄ° - PURPOSE-DRIVEN USAGE

MCP toollarÄ± sÃ¼rekli kullanÄ±lacak araÃ§lar deÄŸil, spesifik durumlar iÃ§in tasarlanmÄ±ÅŸ Ã¶zel araÃ§lardÄ±r. Her tool kullanÄ±mÄ±nÄ±n net bir amacÄ± ve faydasÄ± olmalÄ±dÄ±r.

## SMART ACTIVATION - AKILLI AKTÄ°VASYON

### MCP TOOL KULLANIM KRÄ°TERLERÄ° - STRICT RULES

MCP toollarÄ± SADECE ÅŸu durumlardan biri geÃ§erliyse kullan:

âœ… **COMPLEX MULTI-STEP PROBLEMS** (3+ distinct steps)
- Ã‡oklu dosya analizi gereksinimi
- BaÄŸÄ±mlÄ±lÄ±k zinciri takibi
- Sistemil bug hunting
- Architecture planning

âœ… **MULTIPLE USER REQUESTS** (Single message'da 2+ request)
- "A yap ve B'yi de kontrol et"  
- "X Ã¶zelliÄŸini ekle, Y'yi optimize et"
- "Bug'Ä± dÃ¼zelt ve test et"

âœ… **SYSTEMATIC DEBUGGING** (Root cause analysis)
- Error source unclear
- Multiple potential causes
- Cross-component investigation needed

âœ… **UNFAMILIAR CODEBASE** (First time seeing structure)
- New project exploration
- Complex architecture understanding
- Legacy code investigation

âœ… **EXPLICIT USER REQUEST** 
- "AdÄ±m adÄ±m aÃ§Ä±kla"
- "DetaylÄ± analiz yap"  
- "NasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek istiyorum"

### MCP TOOL KULLANILMAYACAK DURUMLAR - CLEAR RESTRICTIONS

âŒ **SIMPLE SINGLE-STEP TASKS**
- Basic file edits
- Single component creation
- Simple bug fixes
- Straightforward implementations

âŒ **ROUTINE OPERATIONS**
- Import additions
- CSS styling changes
- Variable renaming
- Simple refactoring

âŒ **QUICK ANSWERS**
- Single concept explanations
- Direct code examples
- Status checks

âŒ **TIME-WASTING SCENARIOS**
- Over-analyzing simple problems
- Unnecessary step-by-step for obvious tasks
- Tool usage just for the sake of using tools

## AVAILABLE MCP TOOLS - STRATEGIC USAGE

### mcp-sequentialthinking-tools (CONDITIONAL)

**Purpose**: Step-by-step thinking for complex problems

**Use ONLY when:**
- Task has 3+ interconnected steps
- User explicitly asks "explain step by step"
- Complex debugging with multiple variables
- Architecture planning for multiple components
- Learning complex concepts (educational mode)

**Do NOT use for:**
- Single-step implementations
- Obvious solutions  
- Simple explanations
- Routine tasks

**Usage example:**
```
âœ… APPROPRIATE:
User: "Bu e-commerce sistemini analyze et, checkout flow'u optimize et ve 
payment integration'Ä± gÃ¼ncelle"
â†’ Use sequential thinking (3 major steps)

âŒ INAPPROPRIATE:  
User: "Button'a click handler ekle"
â†’ Direct implementation (no tool needed)
```

### context7 (CONDITIONAL)

**Purpose**: Documentation and library research

**Use ONLY when:**
- Implementing unfamiliar libraries/frameworks
- Need official documentation lookup
- API integration questions
- Library version compatibility checks

**Do NOT use for:**
- Common React/JavaScript patterns
- Well-known library usage  
- Basic implementation questions

**Usage example:**
```
âœ… APPROPRIATE:
User: "Three.js ile 3D animation implement etmek istiyorum"
â†’ Use context7 (unfamiliar library documentation needed)

âŒ INAPPROPRIATE:
User: "useState hook nasÄ±l kullanÄ±lÄ±r?"  
â†’ Direct explanation (well-known pattern)
```

## EFFICIENCY ANALYSIS - COST-BENEFIT

### MCP TOOL OVERHEAD CALCULATION

**Typical overhead per tool usage:**
- Sequential thinking tool: +15-30 seconds
- Context7 documentation: +20-40 seconds  
- Context switching: +5-10 seconds
- Total potential delay: +40-80 seconds per usage

**When overhead is justified:**
- Complex problem solving: Saves 5+ minutes of confusion
- Unfamiliar technology: Prevents hours of wrong direction
- Educational requests: Provides structured learning
- Multi-step tasks: Ensures no steps are missed

**When overhead is wasted:**
- Simple implementations: Adds unnecessary delay
- Known patterns: User gets delayed answer
- Routine tasks: Efficiency killer

### EFFICIENCY OPTIMIZATION RULES

```javascript
function shouldUseMCP(task) {
    const complexity = assessTaskComplexity(task);
    const userIntent = detectUserIntent(task);
    const knowledgeGap = assessKnowledgeGap(task);
    
    const efficiency_score = (complexity * 0.4) + 
                           (userIntent.learning * 0.3) +
                           (knowledgeGap * 0.3);
    
    return efficiency_score > 0.6; // Only use if high efficiency score
}
```

## TOOL-SPECIFIC USAGE PROTOCOLS

### Sequential Thinking Protocol

**Activation checklist:**
- [ ] Task has multiple interconnected steps (3+)
- [ ] Steps have dependencies on each other  
- [ ] User needs to understand the process
- [ ] Complex problem solving required

**Usage pattern:**
```
ğŸ“‹ SEQUENTIAL THINKING ACTIVATED
ğŸ¯ Reason: [specific multi-step problem]
ğŸ“ Steps identified: [number of steps]
âš¡ Expected benefit: [time/confusion saved]
```

### Context7 Protocol

**Activation checklist:**
- [ ] Unfamiliar library/framework implementation
- [ ] Official documentation needed
- [ ] API reference lookup required
- [ ] Version compatibility research needed

**Usage pattern:**
```
ğŸ“š DOCUMENTATION RESEARCH ACTIVATED  
ğŸ” Target: [library/framework name]
ğŸ“– Information needed: [specific documentation type]
âš¡ Expected benefit: [accurate implementation]
```

## ANTI-PATTERNS - TOOL MISUSE PREVENTION

### COMMON MCP TOOL MISUSE SCENARIOS

**Over-Engineering Prevention:**
```
âŒ MISUSE EXAMPLE:
User: "Button component oluÅŸtur"
Wrong approach: Sequential thinking â†’ Plan component â†’ Research best practices â†’ etc.
Correct approach: Direct simple component creation

âŒ MISUSE EXAMPLE:  
User: "CSS color deÄŸiÅŸtir"
Wrong approach: Context7 â†’ Research CSS best practices
Correct approach: Direct color change
```

### EFFICIENCY KILLER PATTERNS

**Pattern 1: Unnecessary Analysis**
- Using sequential thinking for obvious solutions
- Over-analyzing simple requests
- Creating complexity where none exists

**Pattern 2: Documentation Overkill**  
- Looking up docs for common patterns
- Researching basic concepts user already knows
- Context7 for standard library usage

**Pattern 3: Tool Addiction**
- Using tools just because they're available
- Defaulting to tool usage without consideration
- Ignoring direct solution opportunities

## ESCALATION & DE-ESCALATION

### ESCALATION TO MCP TOOLS

**Signals that require MCP activation:**
```
ğŸ”„ ESCALATION TRIGGERS:
- User confusion detected (multiple questions)
- Task complexity higher than initially assessed  
- Unknown technology/pattern encountered
- Multiple interconnected problems found
- Educational deep-dive requested
```

### DE-ESCALATION FROM MCP TOOLS

**Signals to switch to direct approach:**
```  
â¬‡ï¸ DE-ESCALATION TRIGGERS:
- Task simpler than initially thought
- Known patterns/solutions identified
- User wants quick implementation
- Time efficiency more important than deep analysis
- Straightforward solution path clear
```

## COMMUNICATION PROTOCOLS

### MCP ACTIVATION REPORTING

**When activating MCP tools:**
```
ğŸ”§ MCP TOOL AKTÄ°VASYONU:
ğŸ“‹ Tool: [specific tool name]
ğŸ¯ Sebep: [clear justification]  
â±ï¸ Beklenen sÃ¼re: [time estimate]
ğŸ’¡ Beklenen fayda: [specific benefit]
```

### EFFICIENCY REPORTING

**Tool usage impact:**
```
ğŸ“Š MCP TOOL VERÄ°MLÄ°LÄ°K RAPORU:
âš¡ KullanÄ±lan araÃ§: [tool name]
â±ï¸ Harcanan zaman: [actual time]
ğŸ¯ Elde edilen: [concrete results]
ğŸ’ DeÄŸer: [was it worth the overhead?]
```

### NON-USAGE JUSTIFICATION

**When NOT using MCP tools:**
```
ğŸš€ DIRECT IMPLEMENTATION APPROACH:
âš¡ Sebep: [why MCP not needed]
ğŸ¯ Strateji: [direct approach plan]
â±ï¸ Efficiency gain: [time saved estimate]
```

## QUALITY CONTROL FOR TOOL USAGE

### MCP USAGE VALIDATION

Before using any MCP tool, validate:
- [ ] **Complexity requirement met** (3+ steps or unfamiliar territory)
- [ ] **User benefit clear** (educational, debugging, or multi-step)
- [ ] **Efficiency justified** (tool overhead worth the benefit)
- [ ] **Direct approach insufficient** (can't be done simply)

### POST-TOOL EVALUATION

After MCP tool usage:
- [ ] **Goal achieved** (tool solved the intended problem)
- [ ] **Time efficient** (overhead was justified)
- [ ] **User satisfied** (got the needed depth/analysis)
- [ ] **Quality maintained** (didn't compromise code quality)

## CONTEXTUAL USAGE EXAMPLES

### SCENARIO 1: NEW TECHNOLOGY INTEGRATION

**Request:** "Bu projeye Socket.io eklemek istiyorum, real-time chat implement edelim"

**Analysis:**
- Unfamiliar technology: âœ… (Socket.io expertise needed)
- Multi-step process: âœ… (server setup, client integration, chat logic)
- Documentation needed: âœ… (Socket.io best practices)

**Decision:** Use context7 + sequential thinking
```
ğŸ“š Context7: Socket.io documentation lookup
ğŸ“‹ Sequential thinking: Multi-step implementation plan
âš¡ Justified: Unfamiliar tech + complex implementation
```

### SCENARIO 2: SIMPLE COMPONENT REQUEST

**Request:** "Loading spinner component oluÅŸtur"

**Analysis:**
- Single-step task: âŒ (no MCP needed)
- Known pattern: âŒ (basic React component)
- Straightforward: âŒ (direct implementation)

**Decision:** Direct implementation
```
ğŸš€ Direct approach: Simple React component creation
âš¡ Efficiency: No tool overhead needed
ğŸ¯ Result: Immediate working solution
```

### SCENARIO 3: COMPLEX DEBUGGING

**Request:** "Form validation Ã§alÄ±ÅŸmÄ±yor, data submit edilmiyor, backend'de error var"

**Analysis:**
- Multi-step debugging: âœ… (frontend + backend investigation)
- Multiple potential causes: âœ… (systematic approach needed)
- Cross-component issue: âœ… (complex debugging required)

**Decision:** Use sequential thinking
```
ğŸ“‹ Sequential thinking: Systematic debugging approach
ğŸ¯ Steps: Frontend validation â†’ Network layer â†’ Backend validation
âš¡ Justified: Complex multi-layer problem requires structured approach
```

## TOOL COMBINATION STRATEGIES

### WHEN TO COMBINE TOOLS

**Effective combinations:**
- **Sequential thinking + Context7**: Complex implementation of unfamiliar tech
- **Context7 only**: Documentation lookup without multi-step planning
- **Sequential thinking only**: Complex familiar technology implementation

**Avoid over-combining:**
- Don't use both tools for simple tasks
- Don't stack tools without clear individual justification

### COMBINATION EFFICIENCY ANALYSIS

```javascript
const toolCombinationEfficiency = {
    sequential_only: {
        overhead: 20,
        benefit: 'Structured approach',
        best_for: 'Complex familiar problems'
    },
    context7_only: {
        overhead: 30,
        benefit: 'Accurate documentation',
        best_for: 'Unfamiliar simple implementation'
    },
    both_tools: {
        overhead: 50,
        benefit: 'Complete analysis + documentation',
        best_for: 'Complex unfamiliar technology integration'
    }
};
```

## SUCCESS METRICS FOR MCP USAGE

### QUANTITATIVE METRICS
- **Usage frequency**: <30% of total interactions (selective usage)
- **Time efficiency**: Tool overhead should save >2x its cost
- **User satisfaction**: Educational/complex requests better served
- **Code quality**: No quality compromise due to tool usage

### QUALITATIVE INDICATORS
- **User feedback**: "That was exactly what I needed"
- **Problem resolution**: Complex issues properly addressed
- **Learning facilitation**: Educational requests well-structured
- **Time management**: No unnecessary delays in simple tasks

## CONTINUOUS OPTIMIZATION

### USAGE PATTERN ANALYSIS
Regular assessment of MCP tool effectiveness:

```
ğŸ“Š MCP KULLANIM ANALÄ°ZÄ° (HaftalÄ±k):
ğŸ“ˆ Total usage: [X times] / [Y total interactions] = [Z%]
âš¡ Efficiency score: [Average time saved vs. overhead]
ğŸ¯ Success rate: [Problems solved effectively]
ğŸ”„ Adjustment needs: [Pattern improvements needed]
```

### RULE REFINEMENT
Based on usage patterns, continuously refine when to use tools:
- Update complexity thresholds
- Adjust efficiency calculations
- Refine trigger conditions
- Improve tool combination strategies

---

*MCP araÃ§larÄ± gÃ¼Ã§lÃ¼ ama pahalÄ± araÃ§lardÄ±r. AkÄ±llÄ± kullanÄ±m, maksimum fayda ile minimum overhead saÄŸlar.*